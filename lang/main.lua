local shell = require("shell")
local util = require("util")
local offset = util.offset
local reset = util.reset
local printt = util.print1table

local name = shell.resolve(...)
tmp = io.open(name,"r")
local program = tmp:read("*a")
tmp:close()

program = string.gsub(program,"\n"," ")

local function split(data)
  checkArg(1,data,"string")
  local parsed,i = {},1
  for token in string.gmatch(data, "([^ ]+)%s*") do
    parsed[i] = token
    i=i+1
  end
  return parsed
end

local splitdata = split(program)

--printt(splitdata)

------------OPERATIONS-------------------------
local OP_INT = offset()
local OP_PRINT = offset()
local OP_ADD = offset()
local OP_SUB = offset()
local OP_STRING = offset()
local OP_MUL = offset()
local OP_DIV = offset()
local OP_BOOL = offset()
local OP_LABEL = offset()
local OP_GOTO = offset()
local OP_SLEEP = offset()
local OP_FUNC = offset()
local OP_RETURN = offset()
local OP_CALL = offset()
local OP_END = offset()
reset()
------------OPERATIONS-------------------------

local function parse(data)-- table of strings >> table of operation types
  local out = {}

  for i=1,#data,1 do
    local token = data[i]
    local l = string.len(token)
    local s = string.sub(token,1,1)
    local e = string.sub(token,l,l)
    
    out[i] = {}
    
    if tonumber(token) then out[i].op = OP_INT out[i].data = tonumber(token)
    elseif s=="\"" and e=="\"" then out[i].op = OP_STRING out[i].data = string.sub(token,2,l-1)
    elseif s==":" and e==":" then out[i].op = OP_LABEL out[i].data = string.sub(token,2,l-1)
    elseif token =="+" then out[i].op = OP_ADD
    elseif token =="/" then out[i].op = OP_DIV
    elseif token =="*" then out[i].op = OP_MUL
    elseif token == "-" then out[i].op = OP_SUB
    elseif token == "print" then out[i].op = OP_PRINT
    elseif string.sub(token,0,5) == "goto:" then out[i].op = OP_GOTO out[i].data = string.sub(token,6,string.len(token))
    elseif token == "false" then out[i].op = OP_BOOL out[i].data = false
    elseif token == "true" then out[i].op = OP_BOOL  out[i].data = true
    elseif token == "function" then out[i].op = OP_FUNC out[i].data = offset()
    elseif token == "call" then out[i].op = OP_CALL
    elseif token == "return" then out[i].op = OP_RETURN
    elseif token == "end" then out[i].op = OP_END
    elseif token == "sleep" then out[i].op = OP_SLEEP
    else out[i].op = "UNKNOWN" out[i].data = token
    end
  end
  reset()
  return out
end

local parsed = parse(splitdata)

--printt(parsed)

local function gen_program(ops)
  local code = "--Generated by compiler\nlocal _s,_sp = {},1\nlocal function _spp() _sp=_sp+1 end\nlocal function _spd() _sp=_sp-1 end\nlocal function call(f) return _G[f]() end\n--CODE--\n"
  
  for i=1,#ops,1 do
    local op = ops[i].op
    local data = ops[i].data
    if op == OP_INT then code=code.."_s[_sp]="..tostring(data).." _spp()\n"
    elseif op == OP_STRING then code=code.."_s[_sp]=\""..tostring(data).."\" _spp()\n"
    elseif op == OP_LABEL then code=code.."::"..tostring(data).."::\n"
    elseif op == OP_GOTO then code=code.."goto "..tostring(data).." \n"
    elseif op == OP_PRINT then code=code.."print(_s[_sp-1]) _spd()\n"
    elseif op == OP_SLEEP then code=code.."os.sleep(_s[_sp-1]) _spd()\n"
    elseif op == OP_ADD then code=code.."_s[_sp-2]=_s[_sp-2]+_s[_sp-1] _spd()\n"
    elseif op == OP_SUB then code=code.."_s[_sp-2]=_s[_sp-2]-_s[_sp-1] _spd()\n"
    elseif op == OP_MUL then code=code.."_s[_sp-2]=_s[_sp-2]*_s[_sp-1] _spd()\n"
    elseif op == OP_DIV then code=code.."_s[_sp-2]=_s[_sp-2]/_s[_sp-1] _spd()\n"
    elseif op == OP_BOOL then code=code.."_s[_sp]="..tostring(data).." _spp()\n"
    elseif op == OP_FUNC then code=code.."_G.f_"..tostring(data).." = function() \n"
    elseif op == OP_RETURN then code=code.."_spd() return _s[_sp]\n"
    elseif op == OP_END then code=code.."end\n"
    elseif op == OP_CALL then code=code.."_s[_sp-1] = call(\"f_\"..tostring(_s[_sp-1]))\n"
    else code=code.."--"..tostring(op).."  "..tostring(data).."\n"
    end
  end
  reset()
  return code
end

local code = gen_program(parsed)

name=name..".o"

local out = io.open(name,"w")
out:write(code)
out:close()
print("Executing "..name)
os.execute(name)